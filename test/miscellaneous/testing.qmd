```{julia}
using Pkg
Pkg.activate("$(pwd())/test/miscellaneous")

using CounterfactualExplanations
using Random
using PythonCall
using Test

include("$(pwd())/test/utils.jl")

# Load synthetic data, models, generators
synthetic = _load_synthetic()
# generators = generator_catalogue

Random.seed!(0)
torch = PythonCall.pyimport("torch")
```

```{julia}
@testset "PyTorch model test" begin
    model_file = "neural_network_class"
    class_name = "NeuralNetwork"
    model_location = "$(pwd())/test/miscellaneous"
    model_path = "$(pwd())/test/miscellaneous/neural_network_class.py"
    pickle_path = "$(pwd())/test/miscellaneous/pretrained_model.pt"

    for (key, value) in synthetic
        name = string(key)
        @testset "$name" begin
            data = value[:data]
            X = data.X

            create_new_model(data, model_path)
            train_and_save_model(data, model_location, pickle_path)
            
            model_loaded = CounterfactualExplanations.Models.pytorch_model_loader(
                model_location,
                model_file,
                class_name,
                pickle_path
            )

            model_pytorch = CounterfactualExplanations.Models.PyTorchModel(model_loaded, data.likelihood)            
            
            @testset "$name" begin
                @testset "Matrix of inputs" begin
                    @test size(logits(model_pytorch, X))[2] == size(X, 2)
                    @test size(probs(model_pytorch, X))[2] == size(X, 2)
                end
                @testset "Vector of inputs" begin
                    @test size(logits(model_pytorch, X[:, 1]), 2) == 1
                    @test size(probs(model_pytorch, X[:, 1]), 2) == 1
                end
            end

            remove_file(model_path)
            remove_file(pickle_path)
        end
    end
end
```

```{julia}
using Printf

function create_new_model(data::CounterfactualData, model_path::String)
    in_size = size(data.X)[1]
    out_size = size(data.y)[1]

    class_str = """
    from torch import nn

    class NeuralNetwork(nn.Module):
        def __init__(self):
            super().__init__()
            self.model = nn.Sequential(
                nn.Flatten(),
                nn.Linear($(in_size), 32),
                nn.Sigmoid(),
                nn.Linear(32, $(out_size))
            )

        def forward(self, x):
            return self.model(x)
    """

    open(model_path, "w") do f
        @printf(f, "%s", class_str)
    end
end
```

```{julia}
function train_and_save_model(data::CounterfactualData, model_location::String, pickle_path::String)
    sys = PythonCall.pyimport("sys")

    if !in(model_location, sys.path)
        sys.path.append(model_location)
    end

    importlib = PythonCall.pyimport("importlib")
    neural_network_class = importlib.import_module("neural_network_class")
    importlib.reload(neural_network_class)
    NeuralNetwork = neural_network_class.NeuralNetwork
    model = NeuralNetwork()

    x_python, y_python = CounterfactualExplanations.DataPreprocessing.preprocess_python_data(data)

    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)
    loss_fun = torch.nn.BCEWithLogitsLoss()

    # Training
    for _ in 1:100
        # Compute prediction and loss:
        output = model(x_python).squeeze()
        print(output)
        loss = loss_fun(output, y_python.t())
        # Backpropagation:
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
    end

    torch.save(model, pickle_path)
end
```

```{julia}
function remove_file(file_path::String)
    try
        rm(file_path)  # removes the file
        println("File $file_path removed successfully.")
    catch e
        println("Error occurred while removing file $file_path: $e")
    end
end
```