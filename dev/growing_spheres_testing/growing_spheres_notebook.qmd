```{julia}
import Pkg
Pkg.activate("$(pwd())/dev/growing_spheres_testing")

using Revise
using CounterfactualExplanations
using Random
using Flux
```

### Set up the NN_flux
```{julia}
N = 100

counterfactual_data = CounterfactualExplanations.Data.load_moons(N)
x_julia, y_julia = counterfactual_data.X, counterfactual_data.y
# Data: x_julia, y_julia
data = Flux.DataLoader((x_julia, y_julia), batchsize = 1)
input_dim = size(x_julia, 1)
n_hidden = 32
activation = relu
output_dim = 2

nn_flux = Chain(
    Dense(input_dim, n_hidden, activation),
    Dropout(0.1),
    Dense(n_hidden, output_dim)
)

loss(yhat, y_julia) = Flux.Losses.logitbinarycrossentropy(nn_flux(yhat), y_julia)

using Flux.Optimise: update!, Adam
using Statistics

opt = Adam()
avg_loss(data) = Statistics.mean(map(d -> loss(d[1],d[2]), data))

# Training:
for epoch = 1:100
    for d in data
        gs = gradient(Flux.params(nn_flux)) do
            l = loss(d...)
    end
        update!(opt, Flux.params(nn_flux), gs)
    end

    if epoch % 5 == 0
        @info "Epoch " * string(epoch) 
        @show avg_loss(data)
    end
end

M_flux = FluxModel(nn_flux, :classification_multi)

Random.seed!(42)

target = 0
factual = 1

@info "Choose factual's index"
y_chosen_factual_idx = rand(findall(predict_label(M_flux, counterfactual_data) .== factual))

@info "Select factual"
x_random_factual = select_factual(counterfactual_data, y_chosen_factual_idx)
```

### Generate counterfactual
```{julia}
# Define a generator:
generator = CounterfactualExplanations.Models.GrowingSpheresGenerator(n = 5, Î· = 0.1)

ce = CounterfactualExplanations.generate_counterfactual(
    x_random_factual,
    target,
    counterfactual_data,
    M_flux,
    generator
)
```
