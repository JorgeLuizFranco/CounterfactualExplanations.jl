```{julia}
using Pkg: Pkg
Pkg.activate("$(pwd())/dev/growing_spheres_testing")

using Revise
using CounterfactualExplanations
using Random
using Flux
```

### Set up the NN_flux
```{julia}
N = 100

counterfactual_data = CounterfactualExplanations.Data.load_moons(N)
x_julia, y_julia = counterfactual_data.X, counterfactual_data.y
# Data: x_julia, y_julia
data = Flux.DataLoader((x_julia, y_julia); batchsize=1)
input_dim = size(x_julia, 1)
n_hidden = 32
activation = relu
output_dim = 2

nn_flux = Chain(
    Dense(input_dim, n_hidden, activation), Dropout(0.1), Dense(n_hidden, output_dim)
)

loss(yhat, y_julia) = Flux.Losses.logitbinarycrossentropy(nn_flux(yhat), y_julia)

using Flux.Optimise: update!, Adam
using Statistics

opt = Adam()
avg_loss(data) = Statistics.mean(map(d -> loss(d[1], d[2]), data))

# Training:
for epoch in 1:100
    for d in data
        gs = gradient(Flux.params(nn_flux)) do
            l = loss(d...)
        end
        update!(opt, Flux.params(nn_flux), gs)
    end

    if epoch % 5 == 0
        @info "Epoch " * string(epoch)
        @show avg_loss(data)
    end
end

M_flux = FluxModel(nn_flux, :classification_multi)

Random.seed!(42)

target = 0
factual = 1

@info "Choose factual's index"
y_chosen_factual_idx = rand(findall(predict_label(M_flux, counterfactual_data) .== factual))

@info "Select factual"
x_random_factual = select_factual(counterfactual_data, y_chosen_factual_idx)
```

### Generate counterfactual
```{julia}
# Define a generator:
generator = CounterfactualExplanations.Generators.GrowingSpheresGenerator()

ce = CounterfactualExplanations.generate_counterfactual(
    x_random_factual, target, counterfactual_data, M_flux, generator
)
```

```{julia}
CounterfactualExplanations.plot(ce; title="Flux path")
```
```{julia}
# For each ce.search[:path] also print the predict label()
predicted_labels = map(
        e -> CounterfactualExplanations.Models.predict_label(M_flux, counterfactual_data, e),
        ce.search[:path],
    )
println(predicted_labels)
```

```{julia}
println(ce.search[:path])
# println(CounterfactualExplanations.decode_state(ce))
println(ce.s′)
println(target)
println(CounterfactualExplanations.Models.predict_label(
                                    M_flux,
                                    counterfactual_data,
                                    CounterfactualExplanations.decode_state(ce),
                                )[1])
```

# Tests

```{julia}
function _load_synthetic()
    # Data:
    data_sets = Dict(
        :classification_binary => CounterfactualExplanations.Data.load_linearly_separable(),
        :classification_multi => CounterfactualExplanations.Data.load_multi_class(),
    )
    # Models
    synthetic = Dict()
    for (likelihood, data) in data_sets
        models = Dict()
        for (model_name, model) in CounterfactualExplanations.Models.standard_models_catalogue
            M = fit_model(data, model_name)
            models[model_name] = Dict(:raw_model => M.model, :model => M)
        end
        synthetic[likelihood] = Dict(:models => models, :data => data)
    end
    return synthetic
end

synthetic = _load_synthetic()
```

```{julia}
"""
    get_target(counterfactual_data::CounterfactualData, factual_label::RawTargetType)

Returns a target label that is different from the factual label.
"""
function get_target(counterfactual_data::CounterfactualData, factual_label::RawTargetType)
    target = rand(
        counterfactual_data.y_levels[counterfactual_data.y_levels .!= factual_label]
    )
    return target
end
```

```{julia}
using Test
init_perturbation = 2.0

@testset "Growing Spheres" begin
    generator = CounterfactualExplanations.Generators.GrowingSpheresGenerator()
    models = CounterfactualExplanations.Models.standard_models_catalogue

    @testset "Models for synthetic data" begin
        for (key, value) in synthetic
            name = string(key)
            @testset "$name" begin
                counterfactual_data = value[:data]
                X = counterfactual_data.X
                # Loop over values of the dict

                for (model_name, model) in models
                    name = string(model_name)
                    @testset "$name" begin
                        M = CounterfactualExplanations.Models.fit_model(
                            counterfactual_data, model_name
                        )
                        # Randomly selected factual:
                        Random.seed!(123)
                        x = select_factual(counterfactual_data, rand(1:size(X, 2)))
                        # Choose target:
                        y = predict_label(M, counterfactual_data, x)
                        # Return randomly anything that is not factual
                        target = get_target(counterfactual_data, y[1])

                        @testset "Convergence" begin

                            @testset "Non-trivial case" begin
                                counterfactual_data.generative_model = nothing
                                # Threshold reached if converged:
                                counterfactual = generate_counterfactual(
                                    x, target, counterfactual_data, M, generator;
                                )
                                @test CounterfactualExplanations.Models.predict_label(
                                    M,
                                    counterfactual_data,
                                    counterfactual.s′,
                                )[1] == target

                                @test CounterfactualExplanations.terminated(counterfactual)
                            end

                            @testset "Trivial case (already in target class)" begin
                                counterfactual_data.generative_model = nothing
                                # Already in target class:
                                y = CounterfactualExplanations.Models.predict_label(M, counterfactual_data, x)
                                target = y[1]
                                γ = minimum([1 / length(counterfactual_data.y_levels), 0.5])
                                counterfactual = CounterfactualExplanations.generate_counterfactual(
                                    x, target, counterfactual_data, M, generator
                                )
                                @test maximum(
                                    abs.(
                                        counterfactual.x .-
                                        counterfactual.s′
                                    ),
                                ) < init_perturbation
                                @test CounterfactualExplanations.terminated(counterfactual)
                            end
                        end
                    end
                end
            end
        end
    end
end
```