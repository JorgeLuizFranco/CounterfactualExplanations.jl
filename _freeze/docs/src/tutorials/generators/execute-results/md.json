{
  "hash": "8e42e459de4a5ebde26aaae9b49025e7",
  "result": {
    "markdown": "```@meta\nCurrentModule = CounterfactualExplanations \n```\n\n\n\n# Handling Generators\n\nGenerating Counterfactual Explanations can be seen as a generative modelling task because it involves generating samples in the input space: $x \\sim \\mathcal{X}$. In this tutorial, we will introduce how Counterfactual `Generator`s are used. They are discussed in more detail in the explanatory section of the documentation.\n\n## Composable Generators \n\n| !!! warning \\\"Breaking Changes Expected\\\"\n|     Work on this feature is still in its very early stages and breaking changes should be expected. \n\nOne of the key objectives for this package is **Composability**. It turns out that many of the various counterfactual generators that have been proposed in the literature, essentially do the same thing: they optimize an objective function. Formally we have,\n\n$$\n\\begin{aligned}\n\\mathbf{s}^\\prime &= \\arg \\min_{\\mathbf{s}^\\prime \\in \\mathcal{S}} \\left\\{  {\\text{yloss}(M(f(\\mathbf{s}^\\prime)),y^*)}+ \\lambda {\\text{cost}(f(\\mathbf{s}^\\prime)) }  \\right\\} \n\\end{aligned} \n$$ {#eq-general}\n\nwhere $\\text{yloss}$ denotes the main loss function and $\\text{cost}$ is a penalty term [@altmeyer2023endogenous]. \n\nWithout going into further detail here, the important thing to mention is that @eq-general very closely describes how counterfactual search is actually implemented in the package. In other words, all off-the-shelf generators currently implemented work with that same objective. They just vary in the way that penalties are defined, for example. This gives rise to an interesting idea: \n\n> Why not compose generators that combine ideas from different off-the-shelf generators?\n\nThe [`Generator`](@ref) class provides a straightforward way to do this, without requiring users to build custom `Generator`s from scratch. It can be instantiated as follows:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\ngenerator = Generator()\n```\n:::\n\n\nBy default, this creates a `generator` that simply performs gradient descent without any penalties. To modify the behaviour of the `generator`, you can define the counterfactual search objective function using the [`@objective`](@ref) macro:\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n@objective(generator, logitbinarycrossentropy + 0.1distance_l2 + 1.0ddp_diversity)\n```\n:::\n\n\nHere we have essentially created a version of the [`DiCEGenerator`](@ref):\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nce = generate_counterfactual(x, target, counterfactual_data, M, generator; num_counterfactuals=5)\nplot(ce)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](generators_files/figure-commonmark/cell-5-output-1.svg){}\n:::\n:::\n\n\nMultiple macros can be chained using `Chains.jl` making it easy to create entirely new flavours of counterfactual generators. The following generator, for example, combines ideas from DiCE [@mothilal2020explaining], REVISE [@joshi2019realistic] and Greedy [@schut2021generating]:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n@chain generator begin\n    @objective logitcrossentropy + 5.0ddp_diversity     # DiCE (Mothilal et al. 2020)\n    @threshold 0.95\n    @with_optimiser JSMADescent(Î·=0.5)                  # Greedy (Schut et al. 2021)\n    @search_latent_space                                # REVISE (Joshi et al. 2019)\nend\n```\n:::\n\n\n\n\n\n\n::: {.cell execution_count=8}\n\n::: {.cell-output .cell-output-display execution_count=9}\nLet's take this generator to our MNIST dataset and generate a counterfactual explanation for turning a 0 into a 8. \n\n:::\n:::\n\n\n::: {.cell execution_count=9}\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](generators_files/figure-commonmark/cell-10-output-1.svg){}\n:::\n:::\n\n\n## Off-the-Shelf Generators \n\nOff-the-shelf generators are just default recipes for counterfactual generators. Currently, the following off-the-shelf counterfactual generators are implemented in the package:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\ngenerator_catalogue\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nDict{Symbol, Function} with 6 entries:\n  :gravitational => GravitationalGenerator\n  :revise        => REVISEGenerator\n  :dice          => DiCEGenerator\n  :generic       => GenericGenerator\n  :greedy        => GreedyGenerator\n  :claproar      => ClaPROARGenerator\n```\n:::\n:::\n\n\nTo specify the type of generator you want to use, you can simply instantiate it:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\n# Search:\ngenerator = GenericGenerator()\nce = generate_counterfactual(x, target, counterfactual_data, M, generator)\nplot(ce)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n![](generators_files/figure-commonmark/cell-12-output-1.svg){}\n:::\n:::\n\n\nWe generally make an effort to follow the literature as closely as possible when implementing off-the-shelf generators. \n\n## References\n\n",
    "supporting": [
      "generators_files"
    ],
    "filters": []
  }
}