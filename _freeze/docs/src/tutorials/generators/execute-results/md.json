{
  "hash": "d35bba8c451b6d0d25783b17df03bd5f",
  "result": {
    "markdown": "```@meta\nCurrentModule = CounterfactualExplanations \n```\n\n\n\n# Handling Generators\n\nGenerating Counterfactual Explanations can be seen as a generative modelling task because it involves generating samples in the input space: $x \\sim \\mathcal{X}$. In this tutorial, we will introduce how Counterfactual `Generator`s are used. They are discussed in more detail in the explanatory section of the documentation: [ðŸ¤“ Explanation](@ref \"ðŸ¤“ Explanation\").\n\n## Off-the-Shelf Generators \n\nCurrently, the following off-the-shelf counterfactual generators are implemented in the package. \n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\ngenerator_catalogue\n```\n:::\n\n\nThese `Generator`s are just composite types that contain information about how counterfactuals ought to be generated. To specify the type of generator you want to use, you can simply instantiate it:\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n# Search:\ngenerator = GenericGenerator()\nce = generate_counterfactual(x, target, counterfactual_data, M, generator)\nplot(ce)\n```\n:::\n\n\n## Composable Generators \n\n!!! warning \"Breaking Changes Expected\"\n    Work on this feature is still in its very early stages and breaking changes should be expected. \n\nOne of the key objectives for this package is **Composability**. It turns out that many of the various counterfactual generators that have been proposed in the literature, essentially do the same thing: they optimize an objective function. Formally we have,\n\n$$\n\\begin{aligned}\n\\mathbf{s}^\\prime &= \\arg \\min_{\\mathbf{s}^\\prime \\in \\mathcal{S}} \\left\\{  {\\text{yloss}(M(f(\\mathbf{s}^\\prime)),y^*)}+ \\lambda {\\text{cost}(f(\\mathbf{s}^\\prime)) }  \\right\\} \n\\end{aligned} \n$$ {#eq-general}\n\nwhere $\\text{yloss}$ denotes the main loss function and $\\text{cost}$ is a penalty term [@altmeyer2023endogenous]. \n\nWithout going into further detail here, the important thing to mention is that @eq-eq-general very closely describes how counterfactual search is actually implemented in the package. In other words, all off-the-shelf generators currently implemented work with that same objective. They just vary in the way that penalties are defined, for example. This gives rise to an interesting idea: \n\n> Why not compose generators that combine ideas from different off-the-shelf generators?\n\nThe [`ComposableGenerator`](@ref) class provides a straightforward way to do this, without requiring users to build custom `Generator`s from scratch. It can be instantiated as follows:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\ngenerator = ComposableGenerator()\n```\n:::\n\n\nBy default, this creates a `generator` that simply performs gradient descent without any penalties. To modify the behaviour of the `generator`, you can define the counterfactual search objective function using the [`objective`](@ref) macro:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n@objective(generator, logitbinarycrossentropy + 0.1distance_l2 + 10ddp_diversity)\n```\n:::\n\n\nHere we have essentially created a version of the [`DiCEGenerator`](@ref):\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nce = generate_counterfactual(x, target, counterfactual_data, M, generator; num_counterfactuals=5)\nplot(ce)\n```\n:::\n\n\n",
    "supporting": [
      "generators_files"
    ],
    "filters": []
  }
}